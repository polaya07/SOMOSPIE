apiVersion: tekton.dev/v1beta1
kind: PipelineRun
metadata:
  name: somospie-data-generation-pipeline
  annotations:
    tekton.dev/output_artifacts: '{"compute-geotiled": [{"key": "artifacts/$PIPELINERUN/compute-geotiled/aspect.tgz",
      "name": "compute-geotiled-aspect", "path": "/tmp/outputs/aspect/data"}, {"key":
      "artifacts/$PIPELINERUN/compute-geotiled/hill.tgz", "name": "compute-geotiled-hill",
      "path": "/tmp/outputs/hill/data"}, {"key": "artifacts/$PIPELINERUN/compute-geotiled/slope.tgz",
      "name": "compute-geotiled-slope", "path": "/tmp/outputs/slope/data"}], "compute-geotiled-2":
      [{"key": "artifacts/$PIPELINERUN/compute-geotiled-2/aspect.tgz", "name": "compute-geotiled-2-aspect",
      "path": "/tmp/outputs/aspect/data"}, {"key": "artifacts/$PIPELINERUN/compute-geotiled-2/hill.tgz",
      "name": "compute-geotiled-2-hill", "path": "/tmp/outputs/hill/data"}, {"key":
      "artifacts/$PIPELINERUN/compute-geotiled-2/slope.tgz", "name": "compute-geotiled-2-slope",
      "path": "/tmp/outputs/slope/data"}], "compute-geotiled-3": [{"key": "artifacts/$PIPELINERUN/compute-geotiled-3/aspect.tgz",
      "name": "compute-geotiled-3-aspect", "path": "/tmp/outputs/aspect/data"}, {"key":
      "artifacts/$PIPELINERUN/compute-geotiled-3/hill.tgz", "name": "compute-geotiled-3-hill",
      "path": "/tmp/outputs/hill/data"}, {"key": "artifacts/$PIPELINERUN/compute-geotiled-3/slope.tgz",
      "name": "compute-geotiled-3-slope", "path": "/tmp/outputs/slope/data"}], "compute-geotiled-4":
      [{"key": "artifacts/$PIPELINERUN/compute-geotiled-4/aspect.tgz", "name": "compute-geotiled-4-aspect",
      "path": "/tmp/outputs/aspect/data"}, {"key": "artifacts/$PIPELINERUN/compute-geotiled-4/hill.tgz",
      "name": "compute-geotiled-4-hill", "path": "/tmp/outputs/hill/data"}, {"key":
      "artifacts/$PIPELINERUN/compute-geotiled-4/slope.tgz", "name": "compute-geotiled-4-slope",
      "path": "/tmp/outputs/slope/data"}], "compute-geotiled-5": [{"key": "artifacts/$PIPELINERUN/compute-geotiled-5/aspect.tgz",
      "name": "compute-geotiled-5-aspect", "path": "/tmp/outputs/aspect/data"}, {"key":
      "artifacts/$PIPELINERUN/compute-geotiled-5/hill.tgz", "name": "compute-geotiled-5-hill",
      "path": "/tmp/outputs/hill/data"}, {"key": "artifacts/$PIPELINERUN/compute-geotiled-5/slope.tgz",
      "name": "compute-geotiled-5-slope", "path": "/tmp/outputs/slope/data"}], "compute-geotiled-6":
      [{"key": "artifacts/$PIPELINERUN/compute-geotiled-6/aspect.tgz", "name": "compute-geotiled-6-aspect",
      "path": "/tmp/outputs/aspect/data"}, {"key": "artifacts/$PIPELINERUN/compute-geotiled-6/hill.tgz",
      "name": "compute-geotiled-6-hill", "path": "/tmp/outputs/hill/data"}, {"key":
      "artifacts/$PIPELINERUN/compute-geotiled-6/slope.tgz", "name": "compute-geotiled-6-slope",
      "path": "/tmp/outputs/slope/data"}], "compute-geotiled-7": [{"key": "artifacts/$PIPELINERUN/compute-geotiled-7/aspect.tgz",
      "name": "compute-geotiled-7-aspect", "path": "/tmp/outputs/aspect/data"}, {"key":
      "artifacts/$PIPELINERUN/compute-geotiled-7/hill.tgz", "name": "compute-geotiled-7-hill",
      "path": "/tmp/outputs/hill/data"}, {"key": "artifacts/$PIPELINERUN/compute-geotiled-7/slope.tgz",
      "name": "compute-geotiled-7-slope", "path": "/tmp/outputs/slope/data"}], "compute-geotiled-8":
      [{"key": "artifacts/$PIPELINERUN/compute-geotiled-8/aspect.tgz", "name": "compute-geotiled-8-aspect",
      "path": "/tmp/outputs/aspect/data"}, {"key": "artifacts/$PIPELINERUN/compute-geotiled-8/hill.tgz",
      "name": "compute-geotiled-8-hill", "path": "/tmp/outputs/hill/data"}, {"key":
      "artifacts/$PIPELINERUN/compute-geotiled-8/slope.tgz", "name": "compute-geotiled-8-slope",
      "path": "/tmp/outputs/slope/data"}], "compute-geotiled-9": [{"key": "artifacts/$PIPELINERUN/compute-geotiled-9/aspect.tgz",
      "name": "compute-geotiled-9-aspect", "path": "/tmp/outputs/aspect/data"}, {"key":
      "artifacts/$PIPELINERUN/compute-geotiled-9/hill.tgz", "name": "compute-geotiled-9-hill",
      "path": "/tmp/outputs/hill/data"}, {"key": "artifacts/$PIPELINERUN/compute-geotiled-9/slope.tgz",
      "name": "compute-geotiled-9-slope", "path": "/tmp/outputs/slope/data"}], "crop-into-tiles":
      [{"key": "artifacts/$PIPELINERUN/crop-into-tiles/Output.tgz", "name": "crop-into-tiles-Output",
      "path": "/tmp/outputs/Output/data"}], "crop-into-tiles-2": [{"key": "artifacts/$PIPELINERUN/crop-into-tiles-2/Output.tgz",
      "name": "crop-into-tiles-2-Output", "path": "/tmp/outputs/Output/data"}], "crop-into-tiles-3":
      [{"key": "artifacts/$PIPELINERUN/crop-into-tiles-3/Output.tgz", "name": "crop-into-tiles-3-Output",
      "path": "/tmp/outputs/Output/data"}], "crop-into-tiles-4": [{"key": "artifacts/$PIPELINERUN/crop-into-tiles-4/Output.tgz",
      "name": "crop-into-tiles-4-Output", "path": "/tmp/outputs/Output/data"}], "crop-into-tiles-5":
      [{"key": "artifacts/$PIPELINERUN/crop-into-tiles-5/Output.tgz", "name": "crop-into-tiles-5-Output",
      "path": "/tmp/outputs/Output/data"}], "crop-into-tiles-6": [{"key": "artifacts/$PIPELINERUN/crop-into-tiles-6/Output.tgz",
      "name": "crop-into-tiles-6-Output", "path": "/tmp/outputs/Output/data"}], "crop-into-tiles-7":
      [{"key": "artifacts/$PIPELINERUN/crop-into-tiles-7/Output.tgz", "name": "crop-into-tiles-7-Output",
      "path": "/tmp/outputs/Output/data"}], "crop-into-tiles-8": [{"key": "artifacts/$PIPELINERUN/crop-into-tiles-8/Output.tgz",
      "name": "crop-into-tiles-8-Output", "path": "/tmp/outputs/Output/data"}], "crop-into-tiles-9":
      [{"key": "artifacts/$PIPELINERUN/crop-into-tiles-9/Output.tgz", "name": "crop-into-tiles-9-Output",
      "path": "/tmp/outputs/Output/data"}], "load-data": [{"key": "artifacts/$PIPELINERUN/load-data/Output.tgz",
      "name": "load-data-Output", "path": "/tmp/outputs/Output/data"}], "merge-avg":
      [{"key": "artifacts/$PIPELINERUN/merge-avg/Output.tgz", "name": "merge-avg-Output",
      "path": "/tmp/outputs/Output/data"}], "merge-avg-2": [{"key": "artifacts/$PIPELINERUN/merge-avg-2/Output.tgz",
      "name": "merge-avg-2-Output", "path": "/tmp/outputs/Output/data"}], "merge-avg-3":
      [{"key": "artifacts/$PIPELINERUN/merge-avg-3/Output.tgz", "name": "merge-avg-3-Output",
      "path": "/tmp/outputs/Output/data"}], "merge-tiles": [{"key": "artifacts/$PIPELINERUN/merge-tiles/Output.tgz",
      "name": "merge-tiles-Output", "path": "/tmp/outputs/Output/data"}], "reproject":
      [{"key": "artifacts/$PIPELINERUN/reproject/Output.tgz", "name": "reproject-Output",
      "path": "/tmp/outputs/Output/data"}], "reproject-2": [{"key": "artifacts/$PIPELINERUN/reproject-2/Output.tgz",
      "name": "reproject-2-Output", "path": "/tmp/outputs/Output/data"}]}'
    tekton.dev/input_artifacts: '{"compute-geotiled": [{"name": "crop-into-tiles-Output",
      "parent_task": "crop-into-tiles"}, {"name": "pvc-geotiled-name", "parent_task":
      "pvc-geotiled"}], "compute-geotiled-2": [{"name": "crop-into-tiles-2-Output",
      "parent_task": "crop-into-tiles-2"}, {"name": "pvc-geotiled-name", "parent_task":
      "pvc-geotiled"}], "compute-geotiled-3": [{"name": "crop-into-tiles-3-Output",
      "parent_task": "crop-into-tiles-3"}, {"name": "pvc-geotiled-name", "parent_task":
      "pvc-geotiled"}], "compute-geotiled-4": [{"name": "crop-into-tiles-4-Output",
      "parent_task": "crop-into-tiles-4"}, {"name": "pvc-geotiled-name", "parent_task":
      "pvc-geotiled"}], "compute-geotiled-5": [{"name": "crop-into-tiles-5-Output",
      "parent_task": "crop-into-tiles-5"}, {"name": "pvc-geotiled-name", "parent_task":
      "pvc-geotiled"}], "compute-geotiled-6": [{"name": "crop-into-tiles-6-Output",
      "parent_task": "crop-into-tiles-6"}, {"name": "pvc-geotiled-name", "parent_task":
      "pvc-geotiled"}], "compute-geotiled-7": [{"name": "crop-into-tiles-7-Output",
      "parent_task": "crop-into-tiles-7"}, {"name": "pvc-geotiled-name", "parent_task":
      "pvc-geotiled"}], "compute-geotiled-8": [{"name": "crop-into-tiles-8-Output",
      "parent_task": "crop-into-tiles-8"}, {"name": "pvc-geotiled-name", "parent_task":
      "pvc-geotiled"}], "compute-geotiled-9": [{"name": "crop-into-tiles-9-Output",
      "parent_task": "crop-into-tiles-9"}, {"name": "pvc-geotiled-name", "parent_task":
      "pvc-geotiled"}], "crop-into-tiles": [{"name": "pvc-geotiled-name", "parent_task":
      "pvc-geotiled"}, {"name": "reproject-Output", "parent_task": "reproject"}],
      "crop-into-tiles-2": [{"name": "pvc-geotiled-name", "parent_task": "pvc-geotiled"},
      {"name": "reproject-Output", "parent_task": "reproject"}], "crop-into-tiles-3":
      [{"name": "pvc-geotiled-name", "parent_task": "pvc-geotiled"}, {"name": "reproject-Output",
      "parent_task": "reproject"}], "crop-into-tiles-4": [{"name": "pvc-geotiled-name",
      "parent_task": "pvc-geotiled"}, {"name": "reproject-Output", "parent_task":
      "reproject"}], "crop-into-tiles-5": [{"name": "pvc-geotiled-name", "parent_task":
      "pvc-geotiled"}, {"name": "reproject-Output", "parent_task": "reproject"}],
      "crop-into-tiles-6": [{"name": "pvc-geotiled-name", "parent_task": "pvc-geotiled"},
      {"name": "reproject-Output", "parent_task": "reproject"}], "crop-into-tiles-7":
      [{"name": "pvc-geotiled-name", "parent_task": "pvc-geotiled"}, {"name": "reproject-Output",
      "parent_task": "reproject"}], "crop-into-tiles-8": [{"name": "pvc-geotiled-name",
      "parent_task": "pvc-geotiled"}, {"name": "reproject-Output", "parent_task":
      "reproject"}], "crop-into-tiles-9": [{"name": "pvc-geotiled-name", "parent_task":
      "pvc-geotiled"}, {"name": "reproject-Output", "parent_task": "reproject"}],
      "load-data": [{"name": "pvc-geotiled-name", "parent_task": "pvc-geotiled"}],
      "merge-avg": [{"name": "compute-geotiled-2-aspect", "parent_task": "compute-geotiled-2"},
      {"name": "compute-geotiled-3-aspect", "parent_task": "compute-geotiled-3"},
      {"name": "compute-geotiled-4-aspect", "parent_task": "compute-geotiled-4"},
      {"name": "compute-geotiled-5-aspect", "parent_task": "compute-geotiled-5"},
      {"name": "compute-geotiled-6-aspect", "parent_task": "compute-geotiled-6"},
      {"name": "compute-geotiled-7-aspect", "parent_task": "compute-geotiled-7"},
      {"name": "compute-geotiled-8-aspect", "parent_task": "compute-geotiled-8"},
      {"name": "compute-geotiled-9-aspect", "parent_task": "compute-geotiled-9"},
      {"name": "compute-geotiled-aspect", "parent_task": "compute-geotiled"}, {"name":
      "pvc-geotiled-name", "parent_task": "pvc-geotiled"}], "merge-avg-2": [{"name":
      "compute-geotiled-2-hill", "parent_task": "compute-geotiled-2"}, {"name": "compute-geotiled-3-hill",
      "parent_task": "compute-geotiled-3"}, {"name": "compute-geotiled-4-hill", "parent_task":
      "compute-geotiled-4"}, {"name": "compute-geotiled-5-hill", "parent_task": "compute-geotiled-5"},
      {"name": "compute-geotiled-6-hill", "parent_task": "compute-geotiled-6"}, {"name":
      "compute-geotiled-7-hill", "parent_task": "compute-geotiled-7"}, {"name": "compute-geotiled-8-hill",
      "parent_task": "compute-geotiled-8"}, {"name": "compute-geotiled-9-hill", "parent_task":
      "compute-geotiled-9"}, {"name": "compute-geotiled-hill", "parent_task": "compute-geotiled"},
      {"name": "pvc-geotiled-name", "parent_task": "pvc-geotiled"}], "merge-avg-3":
      [{"name": "compute-geotiled-2-slope", "parent_task": "compute-geotiled-2"},
      {"name": "compute-geotiled-3-slope", "parent_task": "compute-geotiled-3"}, {"name":
      "compute-geotiled-4-slope", "parent_task": "compute-geotiled-4"}, {"name": "compute-geotiled-5-slope",
      "parent_task": "compute-geotiled-5"}, {"name": "compute-geotiled-6-slope", "parent_task":
      "compute-geotiled-6"}, {"name": "compute-geotiled-7-slope", "parent_task": "compute-geotiled-7"},
      {"name": "compute-geotiled-8-slope", "parent_task": "compute-geotiled-8"}, {"name":
      "compute-geotiled-9-slope", "parent_task": "compute-geotiled-9"}, {"name": "compute-geotiled-slope",
      "parent_task": "compute-geotiled"}, {"name": "pvc-geotiled-name", "parent_task":
      "pvc-geotiled"}], "merge-tiles": [{"name": "load-data-Output", "parent_task":
      "load-data"}, {"name": "pvc-geotiled-name", "parent_task": "pvc-geotiled"}],
      "reproject": [{"name": "merge-tiles-Output", "parent_task": "merge-tiles"},
      {"name": "pvc-geotiled-name", "parent_task": "pvc-geotiled"}], "reproject-2":
      [{"name": "merge-tiles-Output", "parent_task": "merge-tiles"}, {"name": "pvc-geotiled-name",
      "parent_task": "pvc-geotiled"}]}'
    tekton.dev/artifact_bucket: mlpipeline
    tekton.dev/artifact_endpoint: minio-service.kubeflow:9000
    tekton.dev/artifact_endpoint_scheme: http://
    tekton.dev/artifact_items: '{"compute-geotiled": [["aspect", "$(results.aspect.path)"],
      ["hill", "$(results.hill.path)"], ["slope", "$(results.slope.path)"]], "compute-geotiled-2":
      [["aspect", "$(results.aspect.path)"], ["hill", "$(results.hill.path)"], ["slope",
      "$(results.slope.path)"]], "compute-geotiled-3": [["aspect", "$(results.aspect.path)"],
      ["hill", "$(results.hill.path)"], ["slope", "$(results.slope.path)"]], "compute-geotiled-4":
      [["aspect", "$(results.aspect.path)"], ["hill", "$(results.hill.path)"], ["slope",
      "$(results.slope.path)"]], "compute-geotiled-5": [["aspect", "$(results.aspect.path)"],
      ["hill", "$(results.hill.path)"], ["slope", "$(results.slope.path)"]], "compute-geotiled-6":
      [["aspect", "$(results.aspect.path)"], ["hill", "$(results.hill.path)"], ["slope",
      "$(results.slope.path)"]], "compute-geotiled-7": [["aspect", "$(results.aspect.path)"],
      ["hill", "$(results.hill.path)"], ["slope", "$(results.slope.path)"]], "compute-geotiled-8":
      [["aspect", "$(results.aspect.path)"], ["hill", "$(results.hill.path)"], ["slope",
      "$(results.slope.path)"]], "compute-geotiled-9": [["aspect", "$(results.aspect.path)"],
      ["hill", "$(results.hill.path)"], ["slope", "$(results.slope.path)"]], "crop-into-tiles":
      [["Output", "$(results.Output.path)"]], "crop-into-tiles-2": [["Output", "$(results.Output.path)"]],
      "crop-into-tiles-3": [["Output", "$(results.Output.path)"]], "crop-into-tiles-4":
      [["Output", "$(results.Output.path)"]], "crop-into-tiles-5": [["Output", "$(results.Output.path)"]],
      "crop-into-tiles-6": [["Output", "$(results.Output.path)"]], "crop-into-tiles-7":
      [["Output", "$(results.Output.path)"]], "crop-into-tiles-8": [["Output", "$(results.Output.path)"]],
      "crop-into-tiles-9": [["Output", "$(results.Output.path)"]], "load-data": [["Output",
      "$(results.Output.path)"]], "merge-avg": [["Output", "$(results.Output.path)"]],
      "merge-avg-2": [["Output", "$(results.Output.path)"]], "merge-avg-3": [["Output",
      "$(results.Output.path)"]], "merge-tiles": [["Output", "$(results.Output.path)"]],
      "pvc-geotiled": [], "reproject": [["Output", "$(results.Output.path)"]], "reproject-2":
      [["Output", "$(results.Output.path)"]]}'
    sidecar.istio.io/inject: "false"
    tekton.dev/template: ''
    pipelines.kubeflow.org/big_data_passing_format: $(workspaces.$TASK_NAME.path)/artifacts/$ORIG_PR_NAME/$TASKRUN_NAME/$TASK_PARAM_NAME
    pipelines.kubeflow.org/pipeline_spec: '{"description": "Pipeline for somospie
      data generation", "inputs": [{"default": "olayap/somospie-gdal", "name": "container_image",
      "optional": true, "type": "String"}, {"default": "/cos/OK_30m.txt", "name":
      "links_file", "optional": true, "type": "String"}, {"default": "3", "name":
      "n_tiles", "optional": true, "type": "Integer"}, {"default": "/cos/albers_conus_reference.wkt",
      "name": "projection_file", "optional": true, "type": "String"}, {"default":
      "oklahoma-30m", "name": "cos_name", "optional": true, "type": "String"}], "name":
      "somospie data generation pipeline"}'
  labels:
    pipelines.kubeflow.org/pipelinename: ''
    pipelines.kubeflow.org/generation: ''
spec:
  params:
  - name: container_image
    value: olayap/somospie-gdal
  - name: cos_name
    value: oklahoma-30m
  - name: links_file
    value: /cos/OK_30m.txt
  - name: n_tiles
    value: '3'
  - name: projection_file
    value: /cos/albers_conus_reference.wkt
  pipelineSpec:
    params:
    - name: container_image
      default: olayap/somospie-gdal
    - name: cos_name
      default: oklahoma-30m
    - name: links_file
      default: /cos/OK_30m.txt
    - name: n_tiles
      default: '3'
    - name: projection_file
      default: /cos/albers_conus_reference.wkt
    tasks:
    - name: pvc-geotiled
      params:
      - name: action
        value: create
      - name: output
        value: |
          - name: manifest
            valueFrom: '{}'
          - name: name
            valueFrom: '{.metadata.name}'
          - name: size
            valueFrom: '{.status.capacity.storage}'
      - name: cos_name
        value: $(params.cos_name)
      taskSpec:
        params:
        - description: Action on the resource
          name: action
          type: string
        - default: strategic
          description: Merge strategy when using action patch
          name: merge-strategy
          type: string
        - default: ''
          description: An express to retrieval data from resource.
          name: output
          type: string
        - default: ''
          description: A label selector express to decide if the action on resource
            is success.
          name: success-condition
          type: string
        - default: ''
          description: A label selector express to decide if the action on resource
            is failure.
          name: failure-condition
          type: string
        - default: quay.io/aipipeline/kubectl-wrapper:latest
          description: Kubectl wrapper image
          name: image
          type: string
        - default: "false"
          description: Enable set owner reference for created resource.
          name: set-ownerreference
          type: string
        - name: cos_name
        steps:
        - command:
          - kubeclient
          args:
          - --action=$(params.action)
          - --merge-strategy=$(params.merge-strategy)
          - |
            --manifest=apiVersion: v1
            kind: PersistentVolumeClaim
            metadata:
              annotations:
                ibm.io/auto-create-bucket: 'false'
                ibm.io/auto-delete-bucket: 'false'
                ibm.io/bucket: $(inputs.params.cos_name)
                ibm.io/endpoint: https://s3.us-east.cloud-object-storage.appdomain.cloud
                ibm.io/secret-name: po-secret
              name: $(PIPELINERUN)-pvc-goetiled
            spec:
              accessModes:
              - ReadWriteOnce
              resources:
                requests:
                  storage: 10Gi
              storageClassName: ibmc-s3fs-standard-regional
          - --output=$(params.output)
          - --success-condition=$(params.success-condition)
          - --failure-condition=$(params.failure-condition)
          - --set-ownerreference=$(params.set-ownerreference)
          image: $(params.image)
          name: main
          resources: {}
          env:
          - name: PIPELINERUN
            valueFrom:
              fieldRef:
                fieldPath: metadata.labels['tekton.dev/pipelineRun']
        results:
        - name: manifest
          type: string
          description: '{}'
        - name: name
          type: string
          description: '{.metadata.name}'
        - name: size
          type: string
          description: '{.status.capacity.storage}'
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
    - name: load-data
      params:
      - name: container_image
        value: $(params.container_image)
      - name: links_file
        value: $(params.links_file)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      taskSpec:
        steps:
        - name: main
          args:
          - --file
          - $(inputs.params.links_file)
          - --out-dir
          - /cos/dems/
          - '----output-paths'
          - $(results.Output.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def load_data(file, out_dir):
                import urllib.request
                import os
                if not os.path.exists(out_dir):
                    os.makedirs(out_dir)
                with open(file,'r') as text:
                    for line in text:
                        urllib.request.urlretrieve(line, out_dir+line.split("/")[-1])
                return out_dir

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Load data', description='')
            _parser.add_argument("--file", dest="file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--out-dir", dest="out_dir", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = load_data(**_parsed_args)

            _outputs = [_outputs]

            _output_serializers = [
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: links_file
        - name: pvc-geotiled-name
        results:
        - name: Output
          type: string
          description: /tmp/outputs/Output/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Load data", "outputs":
              [{"name": "Output", "type": "String"}], "version": "Load data@sha256=d322c2b9edcd20a4b5d3f824f945cac09d03a5113fd3e3e0e84bf51860e553a4"}'
    - name: merge-tiles
      params:
      - name: container_image
        value: $(params.container_image)
      - name: load-data-Output
        value: $(tasks.load-data.results.Output)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      taskSpec:
        steps:
        - name: main
          args:
          - --input-dir
          - $(inputs.params.load-data-Output)
          - --output-file
          - /cos/mosaic.tif
          - --cos
          - /cos/
          - '----output-paths'
          - $(results.Output.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def merge_tiles(input_dir, output_file, cos):
                # Packages
                import os
                import glob
                from osgeo import gdal
                input_files=[]
                # get all files from dems directory
                for root, dirs, files in os.walk(os.path.abspath(input_dir)):
                    for file in files:
                        input_files.append(os.path.join(root, file))
                #input_files=os.listdir(input_dir)
                print("Reading TIFFs from: ", input_files)
                # input_files: list of .tif files to merge
                vrt = gdal.BuildVRT(cos+'merged.vrt', input_files)
                translate_options = gdal.TranslateOptions(creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES', 'NUM_THREADS=ALL_CPUS'], callback=gdal.TermProgress_nocb)
                gdal.Translate(output_file, vrt, options=translate_options)
                vrt = None  # closes file
                os.remove(cos+'merged.vrt')
                return output_file

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Merge tiles', description='')
            _parser.add_argument("--input-dir", dest="input_dir", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--output-file", dest="output_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--cos", dest="cos", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = merge_tiles(**_parsed_args)

            _outputs = [_outputs]

            _output_serializers = [
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: load-data-Output
        - name: pvc-geotiled-name
        results:
        - name: Output
          type: string
          description: /tmp/outputs/Output/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Merge tiles",
              "outputs": [{"name": "Output", "type": "String"}], "version": "Merge
              tiles@sha256=1657fd9d546fe287be3ab78fedd41c93f194e6a7e2b8b96620f9afad3a21e6ea"}'
    - name: reproject
      params:
      - name: container_image
        value: $(params.container_image)
      - name: merge-tiles-Output
        value: $(tasks.merge-tiles.results.Output)
      - name: projection_file
        value: $(params.projection_file)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      taskSpec:
        steps:
        - name: main
          args:
          - --input-file
          - $(inputs.params.merge-tiles-Output)
          - --output-file
          - /cos/elevation_m.tif
          - --projection
          - $(inputs.params.projection_file)
          - --nodata
          - "n"
          - '----output-paths'
          - $(results.Output.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - "def reproject(input_file, output_file, projection, nodata='n'):\n   \
            \ # Packages\n    import os\n    from osgeo import gdal\n    import numpy\
            \ as np \n\n    # Projection can be EPSG:4326, .... or the path to a wkt\
            \ file\n    if nodata == 'y':\n        warp_options = gdal.WarpOptions(dstSRS=projection,\
            \ dstNodata=np.nan, creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES',\
            \ 'NUM_THREADS=ALL_CPUS'], multithread=True, warpOptions=['NUM_THREADS=ALL_CPUS'],\
            \ callback=gdal.TermProgress_nocb)\n    else:\n        warp_options =\
            \ gdal.WarpOptions(dstSRS=projection, creationOptions=['COMPRESS=LZW',\
            \ 'TILED=YES', 'BIGTIFF=YES', 'NUM_THREADS=ALL_CPUS'], callback=gdal.TermProgress_nocb,\
            \ multithread=True, warpOptions=['NUM_THREADS=ALL_CPUS'])\n    warp =\
            \ gdal.Warp(output_file, input_file, options=warp_options)\n    warp =\
            \ None  # Closes the files\n    return output_file\n\ndef _serialize_str(str_value:\
            \ str) -> str:\n    if not isinstance(str_value, str):\n        raise\
            \ TypeError('Value \"{}\" has type \"{}\" instead of str.'.format(\n \
            \           str(str_value), str(type(str_value))))\n    return str_value\n\
            \nimport argparse\n_parser = argparse.ArgumentParser(prog='Reproject',\
            \ description='')\n_parser.add_argument(\"--input-file\", dest=\"input_file\"\
            , type=str, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"\
            --output-file\", dest=\"output_file\", type=str, required=True, default=argparse.SUPPRESS)\n\
            _parser.add_argument(\"--projection\", dest=\"projection\", type=str,\
            \ required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--nodata\"\
            , dest=\"nodata\", type=str, required=False, default=argparse.SUPPRESS)\n\
            _parser.add_argument(\"----output-paths\", dest=\"_output_paths\", type=str,\
            \ nargs=1)\n_parsed_args = vars(_parser.parse_args())\n_output_files =\
            \ _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = reproject(**_parsed_args)\n\
            \n_outputs = [_outputs]\n\n_output_serializers = [\n    _serialize_str,\n\
            \n]\n\nimport os\nfor idx, output_file in enumerate(_output_files):\n\
            \    try:\n        os.makedirs(os.path.dirname(output_file))\n    except\
            \ OSError:\n        pass\n    with open(output_file, 'w') as f:\n    \
            \    f.write(_output_serializers[idx](_outputs[idx]))\n"
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: merge-tiles-Output
        - name: projection_file
        - name: pvc-geotiled-name
        results:
        - name: Output
          type: string
          description: /tmp/outputs/Output/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Reproject", "outputs":
              [{"name": "Output", "type": "String"}], "version": "Reproject@sha256=b50635b1110b933c2f84b56e8746862852f50fbba550aa67079a3259d1855398"}'
    - name: crop-into-tiles
      params:
      - name: container_image
        value: $(params.container_image)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      - name: reproject-Output
        value: $(tasks.reproject.results.Output)
      taskSpec:
        steps:
        - name: main
          args:
          - --mosaic
          - $(inputs.params.reproject-Output)
          - --out-file
          - /cos/tile_0000.tif
          - --n-tiles
          - '3'
          - --idx-x
          - '0'
          - --idx-y
          - '0'
          - '----output-paths'
          - $(results.Output.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def crop_into_tiles(mosaic, out_file, n_tiles, idx_x, idx_y):
                import os
                import math
                from osgeo import gdal

                # Functions
                def crop_pixels(input_file, output_file, window):
                    # Window to crop by [left_x, top_y, width, height]
                    translate_options = gdal.TranslateOptions(srcWin=window,
                                                            creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'],
                                                            callback=gdal.TermProgress_nocb)
                    gdal.Translate(output_file, input_file, options=translate_options)

                # idx_x number of the tile in the x dimension

                ds = gdal.Open(mosaic, 0)
                cols = ds.RasterXSize
                rows = ds.RasterYSize
                x_win_size = int(math.ceil(cols / n_tiles))
                y_win_size = int(math.ceil(rows / n_tiles))

                buffer = 10 # 10 pixels
                tile_count = 0

                idx_x = range(0, cols, x_win_size)[idx_x]
                idx_y = range(0, rows, y_win_size)[idx_y]

                if idx_y + y_win_size < rows:
                    nrows = y_win_size
                else:
                    nrows = rows - idx_y

                if idx_x + x_win_size < cols:
                    ncols = x_win_size
                else:
                    ncols = cols - idx_x

                win = [idx_x, idx_y, ncols, nrows]

                # Upper left corner
                win[0] = max(0, win[0] - buffer)
                win[1] = max(0, win[1] - buffer)

                w = win[2] + 2*buffer
                win[2] = w if win[0] + w < cols else cols - win[0]

                h = win[3] + 2*buffer
                win[3] = h if win[1] + h < cols else cols - win[1]

                crop_pixels(mosaic, out_file, win)
                tile_count += 1
                return out_file

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Crop into tiles', description='')
            _parser.add_argument("--mosaic", dest="mosaic", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--out-file", dest="out_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--n-tiles", dest="n_tiles", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-x", dest="idx_x", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-y", dest="idx_y", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = crop_into_tiles(**_parsed_args)

            _outputs = [_outputs]

            _output_serializers = [
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: pvc-geotiled-name
        - name: reproject-Output
        results:
        - name: Output
          type: string
          description: /tmp/outputs/Output/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Crop into tiles",
              "outputs": [{"name": "Output", "type": "String"}], "version": "Crop
              into tiles@sha256=edfe18cb96fd40fa1443fd1f6cc9c4b320660514a87638d9756614730de0240c"}'
      retries: 3
    - name: compute-geotiled
      params:
      - name: container_image
        value: $(params.container_image)
      - name: crop-into-tiles-Output
        value: $(tasks.crop-into-tiles.results.Output)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      taskSpec:
        steps:
        - name: main
          args:
          - --dir
          - /cos/
          - --tile-count
          - '0'
          - --input-file
          - $(inputs.params.crop-into-tiles-Output)
          - --aspect-file
          - /cos/aspect_tile_0000.tif
          - --hillshading-file
          - /cos/hillshading_tile_0000.tif
          - --slope-file
          - /cos/slope_tile_0000.tif
          - '----output-paths'
          - $(results.aspect.path)
          - $(results.hill.path)
          - $(results.slope.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def compute_geotiled(dir, tile_count, input_file, aspect_file, hillshading_file, slope_file):
                ## Packages
                import os
                from osgeo import gdal

                # Slope
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(slope_file, input_file, processing='slope', options=dem_options)
                # Aspect
                dem_options = gdal.DEMProcessingOptions(zeroForFlat=True, format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(aspect_file, input_file, processing='aspect', options=dem_options)
                # Hillshading
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(dir+str(tile_count)+'hill.tif', input_file, processing='hillshade', options=dem_options)

                # Change datatype of hillshading to the same as the other parameters
                translate_options = gdal.TranslateOptions(creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES', 'NUM_THREADS=ALL_CPUS'], outputType=gdal.GDT_Float32, callback=gdal.TermProgress_nocb)
                gdal.Translate(hillshading_file, dir+str(tile_count)+'hill.tif', options=translate_options)
                os.remove(dir+str(tile_count)+'hill.tif')

                return(aspect_file,hillshading_file,slope_file)

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Compute geotiled', description='')
            _parser.add_argument("--dir", dest="dir", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--tile-count", dest="tile_count", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--input-file", dest="input_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--aspect-file", dest="aspect_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--hillshading-file", dest="hillshading_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--slope-file", dest="slope_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=3)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = compute_geotiled(**_parsed_args)

            _output_serializers = [
                _serialize_str,
                _serialize_str,
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: crop-into-tiles-Output
        - name: pvc-geotiled-name
        results:
        - name: aspect
          type: string
          description: /tmp/outputs/aspect/data
        - name: hill
          type: string
          description: /tmp/outputs/hill/data
        - name: slope
          type: string
          description: /tmp/outputs/slope/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Compute geotiled",
              "outputs": [{"name": "aspect", "type": "String"}, {"name": "hill", "type":
              "String"}, {"name": "slope", "type": "String"}], "version": "Compute
              geotiled@sha256=a21a9008c60e92887548b4b28b2dba9a5d5a205dcbd3c7b2859d8ed5cf4cd4e1"}'
      retries: 3
    - name: crop-into-tiles-2
      params:
      - name: container_image
        value: $(params.container_image)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      - name: reproject-Output
        value: $(tasks.reproject.results.Output)
      taskSpec:
        steps:
        - name: main
          args:
          - --mosaic
          - $(inputs.params.reproject-Output)
          - --out-file
          - /cos/tile_0001.tif
          - --n-tiles
          - '3'
          - --idx-x
          - '0'
          - --idx-y
          - '1'
          - '----output-paths'
          - $(results.Output.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def crop_into_tiles(mosaic, out_file, n_tiles, idx_x, idx_y):
                import os
                import math
                from osgeo import gdal

                # Functions
                def crop_pixels(input_file, output_file, window):
                    # Window to crop by [left_x, top_y, width, height]
                    translate_options = gdal.TranslateOptions(srcWin=window,
                                                            creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'],
                                                            callback=gdal.TermProgress_nocb)
                    gdal.Translate(output_file, input_file, options=translate_options)

                # idx_x number of the tile in the x dimension

                ds = gdal.Open(mosaic, 0)
                cols = ds.RasterXSize
                rows = ds.RasterYSize
                x_win_size = int(math.ceil(cols / n_tiles))
                y_win_size = int(math.ceil(rows / n_tiles))

                buffer = 10 # 10 pixels
                tile_count = 0

                idx_x = range(0, cols, x_win_size)[idx_x]
                idx_y = range(0, rows, y_win_size)[idx_y]

                if idx_y + y_win_size < rows:
                    nrows = y_win_size
                else:
                    nrows = rows - idx_y

                if idx_x + x_win_size < cols:
                    ncols = x_win_size
                else:
                    ncols = cols - idx_x

                win = [idx_x, idx_y, ncols, nrows]

                # Upper left corner
                win[0] = max(0, win[0] - buffer)
                win[1] = max(0, win[1] - buffer)

                w = win[2] + 2*buffer
                win[2] = w if win[0] + w < cols else cols - win[0]

                h = win[3] + 2*buffer
                win[3] = h if win[1] + h < cols else cols - win[1]

                crop_pixels(mosaic, out_file, win)
                tile_count += 1
                return out_file

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Crop into tiles', description='')
            _parser.add_argument("--mosaic", dest="mosaic", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--out-file", dest="out_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--n-tiles", dest="n_tiles", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-x", dest="idx_x", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-y", dest="idx_y", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = crop_into_tiles(**_parsed_args)

            _outputs = [_outputs]

            _output_serializers = [
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: pvc-geotiled-name
        - name: reproject-Output
        results:
        - name: Output
          type: string
          description: /tmp/outputs/Output/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Crop into tiles",
              "outputs": [{"name": "Output", "type": "String"}], "version": "Crop
              into tiles@sha256=edfe18cb96fd40fa1443fd1f6cc9c4b320660514a87638d9756614730de0240c"}'
      retries: 3
    - name: compute-geotiled-2
      params:
      - name: container_image
        value: $(params.container_image)
      - name: crop-into-tiles-2-Output
        value: $(tasks.crop-into-tiles-2.results.Output)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      taskSpec:
        steps:
        - name: main
          args:
          - --dir
          - /cos/
          - --tile-count
          - '1'
          - --input-file
          - $(inputs.params.crop-into-tiles-2-Output)
          - --aspect-file
          - /cos/aspect_tile_0001.tif
          - --hillshading-file
          - /cos/hillshading_tile_0001.tif
          - --slope-file
          - /cos/slope_tile_0001.tif
          - '----output-paths'
          - $(results.aspect.path)
          - $(results.hill.path)
          - $(results.slope.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def compute_geotiled(dir, tile_count, input_file, aspect_file, hillshading_file, slope_file):
                ## Packages
                import os
                from osgeo import gdal

                # Slope
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(slope_file, input_file, processing='slope', options=dem_options)
                # Aspect
                dem_options = gdal.DEMProcessingOptions(zeroForFlat=True, format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(aspect_file, input_file, processing='aspect', options=dem_options)
                # Hillshading
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(dir+str(tile_count)+'hill.tif', input_file, processing='hillshade', options=dem_options)

                # Change datatype of hillshading to the same as the other parameters
                translate_options = gdal.TranslateOptions(creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES', 'NUM_THREADS=ALL_CPUS'], outputType=gdal.GDT_Float32, callback=gdal.TermProgress_nocb)
                gdal.Translate(hillshading_file, dir+str(tile_count)+'hill.tif', options=translate_options)
                os.remove(dir+str(tile_count)+'hill.tif')

                return(aspect_file,hillshading_file,slope_file)

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Compute geotiled', description='')
            _parser.add_argument("--dir", dest="dir", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--tile-count", dest="tile_count", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--input-file", dest="input_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--aspect-file", dest="aspect_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--hillshading-file", dest="hillshading_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--slope-file", dest="slope_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=3)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = compute_geotiled(**_parsed_args)

            _output_serializers = [
                _serialize_str,
                _serialize_str,
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: crop-into-tiles-2-Output
        - name: pvc-geotiled-name
        results:
        - name: aspect
          type: string
          description: /tmp/outputs/aspect/data
        - name: hill
          type: string
          description: /tmp/outputs/hill/data
        - name: slope
          type: string
          description: /tmp/outputs/slope/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Compute geotiled",
              "outputs": [{"name": "aspect", "type": "String"}, {"name": "hill", "type":
              "String"}, {"name": "slope", "type": "String"}], "version": "Compute
              geotiled@sha256=a21a9008c60e92887548b4b28b2dba9a5d5a205dcbd3c7b2859d8ed5cf4cd4e1"}'
      retries: 3
    - name: crop-into-tiles-3
      params:
      - name: container_image
        value: $(params.container_image)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      - name: reproject-Output
        value: $(tasks.reproject.results.Output)
      taskSpec:
        steps:
        - name: main
          args:
          - --mosaic
          - $(inputs.params.reproject-Output)
          - --out-file
          - /cos/tile_0002.tif
          - --n-tiles
          - '3'
          - --idx-x
          - '0'
          - --idx-y
          - '2'
          - '----output-paths'
          - $(results.Output.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def crop_into_tiles(mosaic, out_file, n_tiles, idx_x, idx_y):
                import os
                import math
                from osgeo import gdal

                # Functions
                def crop_pixels(input_file, output_file, window):
                    # Window to crop by [left_x, top_y, width, height]
                    translate_options = gdal.TranslateOptions(srcWin=window,
                                                            creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'],
                                                            callback=gdal.TermProgress_nocb)
                    gdal.Translate(output_file, input_file, options=translate_options)

                # idx_x number of the tile in the x dimension

                ds = gdal.Open(mosaic, 0)
                cols = ds.RasterXSize
                rows = ds.RasterYSize
                x_win_size = int(math.ceil(cols / n_tiles))
                y_win_size = int(math.ceil(rows / n_tiles))

                buffer = 10 # 10 pixels
                tile_count = 0

                idx_x = range(0, cols, x_win_size)[idx_x]
                idx_y = range(0, rows, y_win_size)[idx_y]

                if idx_y + y_win_size < rows:
                    nrows = y_win_size
                else:
                    nrows = rows - idx_y

                if idx_x + x_win_size < cols:
                    ncols = x_win_size
                else:
                    ncols = cols - idx_x

                win = [idx_x, idx_y, ncols, nrows]

                # Upper left corner
                win[0] = max(0, win[0] - buffer)
                win[1] = max(0, win[1] - buffer)

                w = win[2] + 2*buffer
                win[2] = w if win[0] + w < cols else cols - win[0]

                h = win[3] + 2*buffer
                win[3] = h if win[1] + h < cols else cols - win[1]

                crop_pixels(mosaic, out_file, win)
                tile_count += 1
                return out_file

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Crop into tiles', description='')
            _parser.add_argument("--mosaic", dest="mosaic", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--out-file", dest="out_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--n-tiles", dest="n_tiles", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-x", dest="idx_x", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-y", dest="idx_y", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = crop_into_tiles(**_parsed_args)

            _outputs = [_outputs]

            _output_serializers = [
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: pvc-geotiled-name
        - name: reproject-Output
        results:
        - name: Output
          type: string
          description: /tmp/outputs/Output/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Crop into tiles",
              "outputs": [{"name": "Output", "type": "String"}], "version": "Crop
              into tiles@sha256=edfe18cb96fd40fa1443fd1f6cc9c4b320660514a87638d9756614730de0240c"}'
      retries: 3
    - name: compute-geotiled-3
      params:
      - name: container_image
        value: $(params.container_image)
      - name: crop-into-tiles-3-Output
        value: $(tasks.crop-into-tiles-3.results.Output)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      taskSpec:
        steps:
        - name: main
          args:
          - --dir
          - /cos/
          - --tile-count
          - '2'
          - --input-file
          - $(inputs.params.crop-into-tiles-3-Output)
          - --aspect-file
          - /cos/aspect_tile_0002.tif
          - --hillshading-file
          - /cos/hillshading_tile_0002.tif
          - --slope-file
          - /cos/slope_tile_0002.tif
          - '----output-paths'
          - $(results.aspect.path)
          - $(results.hill.path)
          - $(results.slope.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def compute_geotiled(dir, tile_count, input_file, aspect_file, hillshading_file, slope_file):
                ## Packages
                import os
                from osgeo import gdal

                # Slope
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(slope_file, input_file, processing='slope', options=dem_options)
                # Aspect
                dem_options = gdal.DEMProcessingOptions(zeroForFlat=True, format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(aspect_file, input_file, processing='aspect', options=dem_options)
                # Hillshading
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(dir+str(tile_count)+'hill.tif', input_file, processing='hillshade', options=dem_options)

                # Change datatype of hillshading to the same as the other parameters
                translate_options = gdal.TranslateOptions(creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES', 'NUM_THREADS=ALL_CPUS'], outputType=gdal.GDT_Float32, callback=gdal.TermProgress_nocb)
                gdal.Translate(hillshading_file, dir+str(tile_count)+'hill.tif', options=translate_options)
                os.remove(dir+str(tile_count)+'hill.tif')

                return(aspect_file,hillshading_file,slope_file)

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Compute geotiled', description='')
            _parser.add_argument("--dir", dest="dir", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--tile-count", dest="tile_count", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--input-file", dest="input_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--aspect-file", dest="aspect_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--hillshading-file", dest="hillshading_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--slope-file", dest="slope_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=3)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = compute_geotiled(**_parsed_args)

            _output_serializers = [
                _serialize_str,
                _serialize_str,
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: crop-into-tiles-3-Output
        - name: pvc-geotiled-name
        results:
        - name: aspect
          type: string
          description: /tmp/outputs/aspect/data
        - name: hill
          type: string
          description: /tmp/outputs/hill/data
        - name: slope
          type: string
          description: /tmp/outputs/slope/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Compute geotiled",
              "outputs": [{"name": "aspect", "type": "String"}, {"name": "hill", "type":
              "String"}, {"name": "slope", "type": "String"}], "version": "Compute
              geotiled@sha256=a21a9008c60e92887548b4b28b2dba9a5d5a205dcbd3c7b2859d8ed5cf4cd4e1"}'
      retries: 3
    - name: crop-into-tiles-4
      params:
      - name: container_image
        value: $(params.container_image)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      - name: reproject-Output
        value: $(tasks.reproject.results.Output)
      taskSpec:
        steps:
        - name: main
          args:
          - --mosaic
          - $(inputs.params.reproject-Output)
          - --out-file
          - /cos/tile_0003.tif
          - --n-tiles
          - '3'
          - --idx-x
          - '1'
          - --idx-y
          - '0'
          - '----output-paths'
          - $(results.Output.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def crop_into_tiles(mosaic, out_file, n_tiles, idx_x, idx_y):
                import os
                import math
                from osgeo import gdal

                # Functions
                def crop_pixels(input_file, output_file, window):
                    # Window to crop by [left_x, top_y, width, height]
                    translate_options = gdal.TranslateOptions(srcWin=window,
                                                            creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'],
                                                            callback=gdal.TermProgress_nocb)
                    gdal.Translate(output_file, input_file, options=translate_options)

                # idx_x number of the tile in the x dimension

                ds = gdal.Open(mosaic, 0)
                cols = ds.RasterXSize
                rows = ds.RasterYSize
                x_win_size = int(math.ceil(cols / n_tiles))
                y_win_size = int(math.ceil(rows / n_tiles))

                buffer = 10 # 10 pixels
                tile_count = 0

                idx_x = range(0, cols, x_win_size)[idx_x]
                idx_y = range(0, rows, y_win_size)[idx_y]

                if idx_y + y_win_size < rows:
                    nrows = y_win_size
                else:
                    nrows = rows - idx_y

                if idx_x + x_win_size < cols:
                    ncols = x_win_size
                else:
                    ncols = cols - idx_x

                win = [idx_x, idx_y, ncols, nrows]

                # Upper left corner
                win[0] = max(0, win[0] - buffer)
                win[1] = max(0, win[1] - buffer)

                w = win[2] + 2*buffer
                win[2] = w if win[0] + w < cols else cols - win[0]

                h = win[3] + 2*buffer
                win[3] = h if win[1] + h < cols else cols - win[1]

                crop_pixels(mosaic, out_file, win)
                tile_count += 1
                return out_file

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Crop into tiles', description='')
            _parser.add_argument("--mosaic", dest="mosaic", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--out-file", dest="out_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--n-tiles", dest="n_tiles", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-x", dest="idx_x", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-y", dest="idx_y", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = crop_into_tiles(**_parsed_args)

            _outputs = [_outputs]

            _output_serializers = [
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: pvc-geotiled-name
        - name: reproject-Output
        results:
        - name: Output
          type: string
          description: /tmp/outputs/Output/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Crop into tiles",
              "outputs": [{"name": "Output", "type": "String"}], "version": "Crop
              into tiles@sha256=edfe18cb96fd40fa1443fd1f6cc9c4b320660514a87638d9756614730de0240c"}'
      retries: 3
    - name: compute-geotiled-4
      params:
      - name: container_image
        value: $(params.container_image)
      - name: crop-into-tiles-4-Output
        value: $(tasks.crop-into-tiles-4.results.Output)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      taskSpec:
        steps:
        - name: main
          args:
          - --dir
          - /cos/
          - --tile-count
          - '3'
          - --input-file
          - $(inputs.params.crop-into-tiles-4-Output)
          - --aspect-file
          - /cos/aspect_tile_0003.tif
          - --hillshading-file
          - /cos/hillshading_tile_0003.tif
          - --slope-file
          - /cos/slope_tile_0003.tif
          - '----output-paths'
          - $(results.aspect.path)
          - $(results.hill.path)
          - $(results.slope.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def compute_geotiled(dir, tile_count, input_file, aspect_file, hillshading_file, slope_file):
                ## Packages
                import os
                from osgeo import gdal

                # Slope
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(slope_file, input_file, processing='slope', options=dem_options)
                # Aspect
                dem_options = gdal.DEMProcessingOptions(zeroForFlat=True, format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(aspect_file, input_file, processing='aspect', options=dem_options)
                # Hillshading
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(dir+str(tile_count)+'hill.tif', input_file, processing='hillshade', options=dem_options)

                # Change datatype of hillshading to the same as the other parameters
                translate_options = gdal.TranslateOptions(creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES', 'NUM_THREADS=ALL_CPUS'], outputType=gdal.GDT_Float32, callback=gdal.TermProgress_nocb)
                gdal.Translate(hillshading_file, dir+str(tile_count)+'hill.tif', options=translate_options)
                os.remove(dir+str(tile_count)+'hill.tif')

                return(aspect_file,hillshading_file,slope_file)

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Compute geotiled', description='')
            _parser.add_argument("--dir", dest="dir", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--tile-count", dest="tile_count", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--input-file", dest="input_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--aspect-file", dest="aspect_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--hillshading-file", dest="hillshading_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--slope-file", dest="slope_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=3)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = compute_geotiled(**_parsed_args)

            _output_serializers = [
                _serialize_str,
                _serialize_str,
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: crop-into-tiles-4-Output
        - name: pvc-geotiled-name
        results:
        - name: aspect
          type: string
          description: /tmp/outputs/aspect/data
        - name: hill
          type: string
          description: /tmp/outputs/hill/data
        - name: slope
          type: string
          description: /tmp/outputs/slope/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Compute geotiled",
              "outputs": [{"name": "aspect", "type": "String"}, {"name": "hill", "type":
              "String"}, {"name": "slope", "type": "String"}], "version": "Compute
              geotiled@sha256=a21a9008c60e92887548b4b28b2dba9a5d5a205dcbd3c7b2859d8ed5cf4cd4e1"}'
      retries: 3
    - name: crop-into-tiles-5
      params:
      - name: container_image
        value: $(params.container_image)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      - name: reproject-Output
        value: $(tasks.reproject.results.Output)
      taskSpec:
        steps:
        - name: main
          args:
          - --mosaic
          - $(inputs.params.reproject-Output)
          - --out-file
          - /cos/tile_0004.tif
          - --n-tiles
          - '3'
          - --idx-x
          - '1'
          - --idx-y
          - '1'
          - '----output-paths'
          - $(results.Output.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def crop_into_tiles(mosaic, out_file, n_tiles, idx_x, idx_y):
                import os
                import math
                from osgeo import gdal

                # Functions
                def crop_pixels(input_file, output_file, window):
                    # Window to crop by [left_x, top_y, width, height]
                    translate_options = gdal.TranslateOptions(srcWin=window,
                                                            creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'],
                                                            callback=gdal.TermProgress_nocb)
                    gdal.Translate(output_file, input_file, options=translate_options)

                # idx_x number of the tile in the x dimension

                ds = gdal.Open(mosaic, 0)
                cols = ds.RasterXSize
                rows = ds.RasterYSize
                x_win_size = int(math.ceil(cols / n_tiles))
                y_win_size = int(math.ceil(rows / n_tiles))

                buffer = 10 # 10 pixels
                tile_count = 0

                idx_x = range(0, cols, x_win_size)[idx_x]
                idx_y = range(0, rows, y_win_size)[idx_y]

                if idx_y + y_win_size < rows:
                    nrows = y_win_size
                else:
                    nrows = rows - idx_y

                if idx_x + x_win_size < cols:
                    ncols = x_win_size
                else:
                    ncols = cols - idx_x

                win = [idx_x, idx_y, ncols, nrows]

                # Upper left corner
                win[0] = max(0, win[0] - buffer)
                win[1] = max(0, win[1] - buffer)

                w = win[2] + 2*buffer
                win[2] = w if win[0] + w < cols else cols - win[0]

                h = win[3] + 2*buffer
                win[3] = h if win[1] + h < cols else cols - win[1]

                crop_pixels(mosaic, out_file, win)
                tile_count += 1
                return out_file

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Crop into tiles', description='')
            _parser.add_argument("--mosaic", dest="mosaic", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--out-file", dest="out_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--n-tiles", dest="n_tiles", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-x", dest="idx_x", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-y", dest="idx_y", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = crop_into_tiles(**_parsed_args)

            _outputs = [_outputs]

            _output_serializers = [
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: pvc-geotiled-name
        - name: reproject-Output
        results:
        - name: Output
          type: string
          description: /tmp/outputs/Output/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Crop into tiles",
              "outputs": [{"name": "Output", "type": "String"}], "version": "Crop
              into tiles@sha256=edfe18cb96fd40fa1443fd1f6cc9c4b320660514a87638d9756614730de0240c"}'
      retries: 3
    - name: compute-geotiled-5
      params:
      - name: container_image
        value: $(params.container_image)
      - name: crop-into-tiles-5-Output
        value: $(tasks.crop-into-tiles-5.results.Output)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      taskSpec:
        steps:
        - name: main
          args:
          - --dir
          - /cos/
          - --tile-count
          - '4'
          - --input-file
          - $(inputs.params.crop-into-tiles-5-Output)
          - --aspect-file
          - /cos/aspect_tile_0004.tif
          - --hillshading-file
          - /cos/hillshading_tile_0004.tif
          - --slope-file
          - /cos/slope_tile_0004.tif
          - '----output-paths'
          - $(results.aspect.path)
          - $(results.hill.path)
          - $(results.slope.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def compute_geotiled(dir, tile_count, input_file, aspect_file, hillshading_file, slope_file):
                ## Packages
                import os
                from osgeo import gdal

                # Slope
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(slope_file, input_file, processing='slope', options=dem_options)
                # Aspect
                dem_options = gdal.DEMProcessingOptions(zeroForFlat=True, format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(aspect_file, input_file, processing='aspect', options=dem_options)
                # Hillshading
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(dir+str(tile_count)+'hill.tif', input_file, processing='hillshade', options=dem_options)

                # Change datatype of hillshading to the same as the other parameters
                translate_options = gdal.TranslateOptions(creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES', 'NUM_THREADS=ALL_CPUS'], outputType=gdal.GDT_Float32, callback=gdal.TermProgress_nocb)
                gdal.Translate(hillshading_file, dir+str(tile_count)+'hill.tif', options=translate_options)
                os.remove(dir+str(tile_count)+'hill.tif')

                return(aspect_file,hillshading_file,slope_file)

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Compute geotiled', description='')
            _parser.add_argument("--dir", dest="dir", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--tile-count", dest="tile_count", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--input-file", dest="input_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--aspect-file", dest="aspect_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--hillshading-file", dest="hillshading_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--slope-file", dest="slope_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=3)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = compute_geotiled(**_parsed_args)

            _output_serializers = [
                _serialize_str,
                _serialize_str,
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: crop-into-tiles-5-Output
        - name: pvc-geotiled-name
        results:
        - name: aspect
          type: string
          description: /tmp/outputs/aspect/data
        - name: hill
          type: string
          description: /tmp/outputs/hill/data
        - name: slope
          type: string
          description: /tmp/outputs/slope/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Compute geotiled",
              "outputs": [{"name": "aspect", "type": "String"}, {"name": "hill", "type":
              "String"}, {"name": "slope", "type": "String"}], "version": "Compute
              geotiled@sha256=a21a9008c60e92887548b4b28b2dba9a5d5a205dcbd3c7b2859d8ed5cf4cd4e1"}'
      retries: 3
    - name: crop-into-tiles-6
      params:
      - name: container_image
        value: $(params.container_image)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      - name: reproject-Output
        value: $(tasks.reproject.results.Output)
      taskSpec:
        steps:
        - name: main
          args:
          - --mosaic
          - $(inputs.params.reproject-Output)
          - --out-file
          - /cos/tile_0005.tif
          - --n-tiles
          - '3'
          - --idx-x
          - '1'
          - --idx-y
          - '2'
          - '----output-paths'
          - $(results.Output.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def crop_into_tiles(mosaic, out_file, n_tiles, idx_x, idx_y):
                import os
                import math
                from osgeo import gdal

                # Functions
                def crop_pixels(input_file, output_file, window):
                    # Window to crop by [left_x, top_y, width, height]
                    translate_options = gdal.TranslateOptions(srcWin=window,
                                                            creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'],
                                                            callback=gdal.TermProgress_nocb)
                    gdal.Translate(output_file, input_file, options=translate_options)

                # idx_x number of the tile in the x dimension

                ds = gdal.Open(mosaic, 0)
                cols = ds.RasterXSize
                rows = ds.RasterYSize
                x_win_size = int(math.ceil(cols / n_tiles))
                y_win_size = int(math.ceil(rows / n_tiles))

                buffer = 10 # 10 pixels
                tile_count = 0

                idx_x = range(0, cols, x_win_size)[idx_x]
                idx_y = range(0, rows, y_win_size)[idx_y]

                if idx_y + y_win_size < rows:
                    nrows = y_win_size
                else:
                    nrows = rows - idx_y

                if idx_x + x_win_size < cols:
                    ncols = x_win_size
                else:
                    ncols = cols - idx_x

                win = [idx_x, idx_y, ncols, nrows]

                # Upper left corner
                win[0] = max(0, win[0] - buffer)
                win[1] = max(0, win[1] - buffer)

                w = win[2] + 2*buffer
                win[2] = w if win[0] + w < cols else cols - win[0]

                h = win[3] + 2*buffer
                win[3] = h if win[1] + h < cols else cols - win[1]

                crop_pixels(mosaic, out_file, win)
                tile_count += 1
                return out_file

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Crop into tiles', description='')
            _parser.add_argument("--mosaic", dest="mosaic", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--out-file", dest="out_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--n-tiles", dest="n_tiles", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-x", dest="idx_x", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-y", dest="idx_y", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = crop_into_tiles(**_parsed_args)

            _outputs = [_outputs]

            _output_serializers = [
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: pvc-geotiled-name
        - name: reproject-Output
        results:
        - name: Output
          type: string
          description: /tmp/outputs/Output/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Crop into tiles",
              "outputs": [{"name": "Output", "type": "String"}], "version": "Crop
              into tiles@sha256=edfe18cb96fd40fa1443fd1f6cc9c4b320660514a87638d9756614730de0240c"}'
      retries: 3
    - name: compute-geotiled-6
      params:
      - name: container_image
        value: $(params.container_image)
      - name: crop-into-tiles-6-Output
        value: $(tasks.crop-into-tiles-6.results.Output)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      taskSpec:
        steps:
        - name: main
          args:
          - --dir
          - /cos/
          - --tile-count
          - '5'
          - --input-file
          - $(inputs.params.crop-into-tiles-6-Output)
          - --aspect-file
          - /cos/aspect_tile_0005.tif
          - --hillshading-file
          - /cos/hillshading_tile_0005.tif
          - --slope-file
          - /cos/slope_tile_0005.tif
          - '----output-paths'
          - $(results.aspect.path)
          - $(results.hill.path)
          - $(results.slope.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def compute_geotiled(dir, tile_count, input_file, aspect_file, hillshading_file, slope_file):
                ## Packages
                import os
                from osgeo import gdal

                # Slope
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(slope_file, input_file, processing='slope', options=dem_options)
                # Aspect
                dem_options = gdal.DEMProcessingOptions(zeroForFlat=True, format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(aspect_file, input_file, processing='aspect', options=dem_options)
                # Hillshading
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(dir+str(tile_count)+'hill.tif', input_file, processing='hillshade', options=dem_options)

                # Change datatype of hillshading to the same as the other parameters
                translate_options = gdal.TranslateOptions(creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES', 'NUM_THREADS=ALL_CPUS'], outputType=gdal.GDT_Float32, callback=gdal.TermProgress_nocb)
                gdal.Translate(hillshading_file, dir+str(tile_count)+'hill.tif', options=translate_options)
                os.remove(dir+str(tile_count)+'hill.tif')

                return(aspect_file,hillshading_file,slope_file)

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Compute geotiled', description='')
            _parser.add_argument("--dir", dest="dir", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--tile-count", dest="tile_count", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--input-file", dest="input_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--aspect-file", dest="aspect_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--hillshading-file", dest="hillshading_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--slope-file", dest="slope_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=3)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = compute_geotiled(**_parsed_args)

            _output_serializers = [
                _serialize_str,
                _serialize_str,
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: crop-into-tiles-6-Output
        - name: pvc-geotiled-name
        results:
        - name: aspect
          type: string
          description: /tmp/outputs/aspect/data
        - name: hill
          type: string
          description: /tmp/outputs/hill/data
        - name: slope
          type: string
          description: /tmp/outputs/slope/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Compute geotiled",
              "outputs": [{"name": "aspect", "type": "String"}, {"name": "hill", "type":
              "String"}, {"name": "slope", "type": "String"}], "version": "Compute
              geotiled@sha256=a21a9008c60e92887548b4b28b2dba9a5d5a205dcbd3c7b2859d8ed5cf4cd4e1"}'
      retries: 3
    - name: crop-into-tiles-7
      params:
      - name: container_image
        value: $(params.container_image)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      - name: reproject-Output
        value: $(tasks.reproject.results.Output)
      taskSpec:
        steps:
        - name: main
          args:
          - --mosaic
          - $(inputs.params.reproject-Output)
          - --out-file
          - /cos/tile_0006.tif
          - --n-tiles
          - '3'
          - --idx-x
          - '2'
          - --idx-y
          - '0'
          - '----output-paths'
          - $(results.Output.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def crop_into_tiles(mosaic, out_file, n_tiles, idx_x, idx_y):
                import os
                import math
                from osgeo import gdal

                # Functions
                def crop_pixels(input_file, output_file, window):
                    # Window to crop by [left_x, top_y, width, height]
                    translate_options = gdal.TranslateOptions(srcWin=window,
                                                            creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'],
                                                            callback=gdal.TermProgress_nocb)
                    gdal.Translate(output_file, input_file, options=translate_options)

                # idx_x number of the tile in the x dimension

                ds = gdal.Open(mosaic, 0)
                cols = ds.RasterXSize
                rows = ds.RasterYSize
                x_win_size = int(math.ceil(cols / n_tiles))
                y_win_size = int(math.ceil(rows / n_tiles))

                buffer = 10 # 10 pixels
                tile_count = 0

                idx_x = range(0, cols, x_win_size)[idx_x]
                idx_y = range(0, rows, y_win_size)[idx_y]

                if idx_y + y_win_size < rows:
                    nrows = y_win_size
                else:
                    nrows = rows - idx_y

                if idx_x + x_win_size < cols:
                    ncols = x_win_size
                else:
                    ncols = cols - idx_x

                win = [idx_x, idx_y, ncols, nrows]

                # Upper left corner
                win[0] = max(0, win[0] - buffer)
                win[1] = max(0, win[1] - buffer)

                w = win[2] + 2*buffer
                win[2] = w if win[0] + w < cols else cols - win[0]

                h = win[3] + 2*buffer
                win[3] = h if win[1] + h < cols else cols - win[1]

                crop_pixels(mosaic, out_file, win)
                tile_count += 1
                return out_file

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Crop into tiles', description='')
            _parser.add_argument("--mosaic", dest="mosaic", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--out-file", dest="out_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--n-tiles", dest="n_tiles", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-x", dest="idx_x", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-y", dest="idx_y", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = crop_into_tiles(**_parsed_args)

            _outputs = [_outputs]

            _output_serializers = [
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: pvc-geotiled-name
        - name: reproject-Output
        results:
        - name: Output
          type: string
          description: /tmp/outputs/Output/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Crop into tiles",
              "outputs": [{"name": "Output", "type": "String"}], "version": "Crop
              into tiles@sha256=edfe18cb96fd40fa1443fd1f6cc9c4b320660514a87638d9756614730de0240c"}'
      retries: 3
    - name: compute-geotiled-7
      params:
      - name: container_image
        value: $(params.container_image)
      - name: crop-into-tiles-7-Output
        value: $(tasks.crop-into-tiles-7.results.Output)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      taskSpec:
        steps:
        - name: main
          args:
          - --dir
          - /cos/
          - --tile-count
          - '6'
          - --input-file
          - $(inputs.params.crop-into-tiles-7-Output)
          - --aspect-file
          - /cos/aspect_tile_0006.tif
          - --hillshading-file
          - /cos/hillshading_tile_0006.tif
          - --slope-file
          - /cos/slope_tile_0006.tif
          - '----output-paths'
          - $(results.aspect.path)
          - $(results.hill.path)
          - $(results.slope.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def compute_geotiled(dir, tile_count, input_file, aspect_file, hillshading_file, slope_file):
                ## Packages
                import os
                from osgeo import gdal

                # Slope
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(slope_file, input_file, processing='slope', options=dem_options)
                # Aspect
                dem_options = gdal.DEMProcessingOptions(zeroForFlat=True, format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(aspect_file, input_file, processing='aspect', options=dem_options)
                # Hillshading
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(dir+str(tile_count)+'hill.tif', input_file, processing='hillshade', options=dem_options)

                # Change datatype of hillshading to the same as the other parameters
                translate_options = gdal.TranslateOptions(creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES', 'NUM_THREADS=ALL_CPUS'], outputType=gdal.GDT_Float32, callback=gdal.TermProgress_nocb)
                gdal.Translate(hillshading_file, dir+str(tile_count)+'hill.tif', options=translate_options)
                os.remove(dir+str(tile_count)+'hill.tif')

                return(aspect_file,hillshading_file,slope_file)

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Compute geotiled', description='')
            _parser.add_argument("--dir", dest="dir", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--tile-count", dest="tile_count", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--input-file", dest="input_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--aspect-file", dest="aspect_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--hillshading-file", dest="hillshading_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--slope-file", dest="slope_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=3)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = compute_geotiled(**_parsed_args)

            _output_serializers = [
                _serialize_str,
                _serialize_str,
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: crop-into-tiles-7-Output
        - name: pvc-geotiled-name
        results:
        - name: aspect
          type: string
          description: /tmp/outputs/aspect/data
        - name: hill
          type: string
          description: /tmp/outputs/hill/data
        - name: slope
          type: string
          description: /tmp/outputs/slope/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Compute geotiled",
              "outputs": [{"name": "aspect", "type": "String"}, {"name": "hill", "type":
              "String"}, {"name": "slope", "type": "String"}], "version": "Compute
              geotiled@sha256=a21a9008c60e92887548b4b28b2dba9a5d5a205dcbd3c7b2859d8ed5cf4cd4e1"}'
      retries: 3
    - name: crop-into-tiles-8
      params:
      - name: container_image
        value: $(params.container_image)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      - name: reproject-Output
        value: $(tasks.reproject.results.Output)
      taskSpec:
        steps:
        - name: main
          args:
          - --mosaic
          - $(inputs.params.reproject-Output)
          - --out-file
          - /cos/tile_0007.tif
          - --n-tiles
          - '3'
          - --idx-x
          - '2'
          - --idx-y
          - '1'
          - '----output-paths'
          - $(results.Output.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def crop_into_tiles(mosaic, out_file, n_tiles, idx_x, idx_y):
                import os
                import math
                from osgeo import gdal

                # Functions
                def crop_pixels(input_file, output_file, window):
                    # Window to crop by [left_x, top_y, width, height]
                    translate_options = gdal.TranslateOptions(srcWin=window,
                                                            creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'],
                                                            callback=gdal.TermProgress_nocb)
                    gdal.Translate(output_file, input_file, options=translate_options)

                # idx_x number of the tile in the x dimension

                ds = gdal.Open(mosaic, 0)
                cols = ds.RasterXSize
                rows = ds.RasterYSize
                x_win_size = int(math.ceil(cols / n_tiles))
                y_win_size = int(math.ceil(rows / n_tiles))

                buffer = 10 # 10 pixels
                tile_count = 0

                idx_x = range(0, cols, x_win_size)[idx_x]
                idx_y = range(0, rows, y_win_size)[idx_y]

                if idx_y + y_win_size < rows:
                    nrows = y_win_size
                else:
                    nrows = rows - idx_y

                if idx_x + x_win_size < cols:
                    ncols = x_win_size
                else:
                    ncols = cols - idx_x

                win = [idx_x, idx_y, ncols, nrows]

                # Upper left corner
                win[0] = max(0, win[0] - buffer)
                win[1] = max(0, win[1] - buffer)

                w = win[2] + 2*buffer
                win[2] = w if win[0] + w < cols else cols - win[0]

                h = win[3] + 2*buffer
                win[3] = h if win[1] + h < cols else cols - win[1]

                crop_pixels(mosaic, out_file, win)
                tile_count += 1
                return out_file

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Crop into tiles', description='')
            _parser.add_argument("--mosaic", dest="mosaic", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--out-file", dest="out_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--n-tiles", dest="n_tiles", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-x", dest="idx_x", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-y", dest="idx_y", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = crop_into_tiles(**_parsed_args)

            _outputs = [_outputs]

            _output_serializers = [
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: pvc-geotiled-name
        - name: reproject-Output
        results:
        - name: Output
          type: string
          description: /tmp/outputs/Output/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Crop into tiles",
              "outputs": [{"name": "Output", "type": "String"}], "version": "Crop
              into tiles@sha256=edfe18cb96fd40fa1443fd1f6cc9c4b320660514a87638d9756614730de0240c"}'
      retries: 3
    - name: compute-geotiled-8
      params:
      - name: container_image
        value: $(params.container_image)
      - name: crop-into-tiles-8-Output
        value: $(tasks.crop-into-tiles-8.results.Output)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      taskSpec:
        steps:
        - name: main
          args:
          - --dir
          - /cos/
          - --tile-count
          - '7'
          - --input-file
          - $(inputs.params.crop-into-tiles-8-Output)
          - --aspect-file
          - /cos/aspect_tile_0007.tif
          - --hillshading-file
          - /cos/hillshading_tile_0007.tif
          - --slope-file
          - /cos/slope_tile_0007.tif
          - '----output-paths'
          - $(results.aspect.path)
          - $(results.hill.path)
          - $(results.slope.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def compute_geotiled(dir, tile_count, input_file, aspect_file, hillshading_file, slope_file):
                ## Packages
                import os
                from osgeo import gdal

                # Slope
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(slope_file, input_file, processing='slope', options=dem_options)
                # Aspect
                dem_options = gdal.DEMProcessingOptions(zeroForFlat=True, format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(aspect_file, input_file, processing='aspect', options=dem_options)
                # Hillshading
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(dir+str(tile_count)+'hill.tif', input_file, processing='hillshade', options=dem_options)

                # Change datatype of hillshading to the same as the other parameters
                translate_options = gdal.TranslateOptions(creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES', 'NUM_THREADS=ALL_CPUS'], outputType=gdal.GDT_Float32, callback=gdal.TermProgress_nocb)
                gdal.Translate(hillshading_file, dir+str(tile_count)+'hill.tif', options=translate_options)
                os.remove(dir+str(tile_count)+'hill.tif')

                return(aspect_file,hillshading_file,slope_file)

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Compute geotiled', description='')
            _parser.add_argument("--dir", dest="dir", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--tile-count", dest="tile_count", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--input-file", dest="input_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--aspect-file", dest="aspect_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--hillshading-file", dest="hillshading_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--slope-file", dest="slope_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=3)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = compute_geotiled(**_parsed_args)

            _output_serializers = [
                _serialize_str,
                _serialize_str,
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: crop-into-tiles-8-Output
        - name: pvc-geotiled-name
        results:
        - name: aspect
          type: string
          description: /tmp/outputs/aspect/data
        - name: hill
          type: string
          description: /tmp/outputs/hill/data
        - name: slope
          type: string
          description: /tmp/outputs/slope/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Compute geotiled",
              "outputs": [{"name": "aspect", "type": "String"}, {"name": "hill", "type":
              "String"}, {"name": "slope", "type": "String"}], "version": "Compute
              geotiled@sha256=a21a9008c60e92887548b4b28b2dba9a5d5a205dcbd3c7b2859d8ed5cf4cd4e1"}'
      retries: 3
    - name: crop-into-tiles-9
      params:
      - name: container_image
        value: $(params.container_image)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      - name: reproject-Output
        value: $(tasks.reproject.results.Output)
      taskSpec:
        steps:
        - name: main
          args:
          - --mosaic
          - $(inputs.params.reproject-Output)
          - --out-file
          - /cos/tile_0008.tif
          - --n-tiles
          - '3'
          - --idx-x
          - '2'
          - --idx-y
          - '2'
          - '----output-paths'
          - $(results.Output.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def crop_into_tiles(mosaic, out_file, n_tiles, idx_x, idx_y):
                import os
                import math
                from osgeo import gdal

                # Functions
                def crop_pixels(input_file, output_file, window):
                    # Window to crop by [left_x, top_y, width, height]
                    translate_options = gdal.TranslateOptions(srcWin=window,
                                                            creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'],
                                                            callback=gdal.TermProgress_nocb)
                    gdal.Translate(output_file, input_file, options=translate_options)

                # idx_x number of the tile in the x dimension

                ds = gdal.Open(mosaic, 0)
                cols = ds.RasterXSize
                rows = ds.RasterYSize
                x_win_size = int(math.ceil(cols / n_tiles))
                y_win_size = int(math.ceil(rows / n_tiles))

                buffer = 10 # 10 pixels
                tile_count = 0

                idx_x = range(0, cols, x_win_size)[idx_x]
                idx_y = range(0, rows, y_win_size)[idx_y]

                if idx_y + y_win_size < rows:
                    nrows = y_win_size
                else:
                    nrows = rows - idx_y

                if idx_x + x_win_size < cols:
                    ncols = x_win_size
                else:
                    ncols = cols - idx_x

                win = [idx_x, idx_y, ncols, nrows]

                # Upper left corner
                win[0] = max(0, win[0] - buffer)
                win[1] = max(0, win[1] - buffer)

                w = win[2] + 2*buffer
                win[2] = w if win[0] + w < cols else cols - win[0]

                h = win[3] + 2*buffer
                win[3] = h if win[1] + h < cols else cols - win[1]

                crop_pixels(mosaic, out_file, win)
                tile_count += 1
                return out_file

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Crop into tiles', description='')
            _parser.add_argument("--mosaic", dest="mosaic", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--out-file", dest="out_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--n-tiles", dest="n_tiles", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-x", dest="idx_x", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--idx-y", dest="idx_y", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = crop_into_tiles(**_parsed_args)

            _outputs = [_outputs]

            _output_serializers = [
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: pvc-geotiled-name
        - name: reproject-Output
        results:
        - name: Output
          type: string
          description: /tmp/outputs/Output/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Crop into tiles",
              "outputs": [{"name": "Output", "type": "String"}], "version": "Crop
              into tiles@sha256=edfe18cb96fd40fa1443fd1f6cc9c4b320660514a87638d9756614730de0240c"}'
      retries: 3
    - name: compute-geotiled-9
      params:
      - name: container_image
        value: $(params.container_image)
      - name: crop-into-tiles-9-Output
        value: $(tasks.crop-into-tiles-9.results.Output)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      taskSpec:
        steps:
        - name: main
          args:
          - --dir
          - /cos/
          - --tile-count
          - '8'
          - --input-file
          - $(inputs.params.crop-into-tiles-9-Output)
          - --aspect-file
          - /cos/aspect_tile_0008.tif
          - --hillshading-file
          - /cos/hillshading_tile_0008.tif
          - --slope-file
          - /cos/slope_tile_0008.tif
          - '----output-paths'
          - $(results.aspect.path)
          - $(results.hill.path)
          - $(results.slope.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def compute_geotiled(dir, tile_count, input_file, aspect_file, hillshading_file, slope_file):
                ## Packages
                import os
                from osgeo import gdal

                # Slope
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(slope_file, input_file, processing='slope', options=dem_options)
                # Aspect
                dem_options = gdal.DEMProcessingOptions(zeroForFlat=True, format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(aspect_file, input_file, processing='aspect', options=dem_options)
                # Hillshading
                dem_options = gdal.DEMProcessingOptions(format='GTiff', creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES'])
                gdal.DEMProcessing(dir+str(tile_count)+'hill.tif', input_file, processing='hillshade', options=dem_options)

                # Change datatype of hillshading to the same as the other parameters
                translate_options = gdal.TranslateOptions(creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES', 'NUM_THREADS=ALL_CPUS'], outputType=gdal.GDT_Float32, callback=gdal.TermProgress_nocb)
                gdal.Translate(hillshading_file, dir+str(tile_count)+'hill.tif', options=translate_options)
                os.remove(dir+str(tile_count)+'hill.tif')

                return(aspect_file,hillshading_file,slope_file)

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import argparse
            _parser = argparse.ArgumentParser(prog='Compute geotiled', description='')
            _parser.add_argument("--dir", dest="dir", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--tile-count", dest="tile_count", type=int, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--input-file", dest="input_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--aspect-file", dest="aspect_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--hillshading-file", dest="hillshading_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--slope-file", dest="slope_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=3)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = compute_geotiled(**_parsed_args)

            _output_serializers = [
                _serialize_str,
                _serialize_str,
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: crop-into-tiles-9-Output
        - name: pvc-geotiled-name
        results:
        - name: aspect
          type: string
          description: /tmp/outputs/aspect/data
        - name: hill
          type: string
          description: /tmp/outputs/hill/data
        - name: slope
          type: string
          description: /tmp/outputs/slope/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Compute geotiled",
              "outputs": [{"name": "aspect", "type": "String"}, {"name": "hill", "type":
              "String"}, {"name": "slope", "type": "String"}], "version": "Compute
              geotiled@sha256=a21a9008c60e92887548b4b28b2dba9a5d5a205dcbd3c7b2859d8ed5cf4cd4e1"}'
      retries: 3
    - name: reproject-2
      params:
      - name: container_image
        value: $(params.container_image)
      - name: merge-tiles-Output
        value: $(tasks.merge-tiles.results.Output)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      taskSpec:
        steps:
        - name: main
          args:
          - --input-file
          - $(inputs.params.merge-tiles-Output)
          - --output-file
          - /cos/elevation.tif
          - --projection
          - EPSG:4326
          - --nodata
          - "y"
          - '----output-paths'
          - $(results.Output.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - "def reproject(input_file, output_file, projection, nodata='n'):\n   \
            \ # Packages\n    import os\n    from osgeo import gdal\n    import numpy\
            \ as np \n\n    # Projection can be EPSG:4326, .... or the path to a wkt\
            \ file\n    if nodata == 'y':\n        warp_options = gdal.WarpOptions(dstSRS=projection,\
            \ dstNodata=np.nan, creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES',\
            \ 'NUM_THREADS=ALL_CPUS'], multithread=True, warpOptions=['NUM_THREADS=ALL_CPUS'],\
            \ callback=gdal.TermProgress_nocb)\n    else:\n        warp_options =\
            \ gdal.WarpOptions(dstSRS=projection, creationOptions=['COMPRESS=LZW',\
            \ 'TILED=YES', 'BIGTIFF=YES', 'NUM_THREADS=ALL_CPUS'], callback=gdal.TermProgress_nocb,\
            \ multithread=True, warpOptions=['NUM_THREADS=ALL_CPUS'])\n    warp =\
            \ gdal.Warp(output_file, input_file, options=warp_options)\n    warp =\
            \ None  # Closes the files\n    return output_file\n\ndef _serialize_str(str_value:\
            \ str) -> str:\n    if not isinstance(str_value, str):\n        raise\
            \ TypeError('Value \"{}\" has type \"{}\" instead of str.'.format(\n \
            \           str(str_value), str(type(str_value))))\n    return str_value\n\
            \nimport argparse\n_parser = argparse.ArgumentParser(prog='Reproject',\
            \ description='')\n_parser.add_argument(\"--input-file\", dest=\"input_file\"\
            , type=str, required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"\
            --output-file\", dest=\"output_file\", type=str, required=True, default=argparse.SUPPRESS)\n\
            _parser.add_argument(\"--projection\", dest=\"projection\", type=str,\
            \ required=True, default=argparse.SUPPRESS)\n_parser.add_argument(\"--nodata\"\
            , dest=\"nodata\", type=str, required=False, default=argparse.SUPPRESS)\n\
            _parser.add_argument(\"----output-paths\", dest=\"_output_paths\", type=str,\
            \ nargs=1)\n_parsed_args = vars(_parser.parse_args())\n_output_files =\
            \ _parsed_args.pop(\"_output_paths\", [])\n\n_outputs = reproject(**_parsed_args)\n\
            \n_outputs = [_outputs]\n\n_output_serializers = [\n    _serialize_str,\n\
            \n]\n\nimport os\nfor idx, output_file in enumerate(_output_files):\n\
            \    try:\n        os.makedirs(os.path.dirname(output_file))\n    except\
            \ OSError:\n        pass\n    with open(output_file, 'w') as f:\n    \
            \    f.write(_output_serializers[idx](_outputs[idx]))\n"
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: container_image
        - name: merge-tiles-Output
        - name: pvc-geotiled-name
        results:
        - name: Output
          type: string
          description: /tmp/outputs/Output/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Reproject", "outputs":
              [{"name": "Output", "type": "String"}], "version": "Reproject@sha256=b50635b1110b933c2f84b56e8746862852f50fbba550aa67079a3259d1855398"}'
      retries: 3
    - name: merge-avg
      params:
      - name: compute-geotiled-2-aspect
        value: $(tasks.compute-geotiled-2.results.aspect)
      - name: compute-geotiled-3-aspect
        value: $(tasks.compute-geotiled-3.results.aspect)
      - name: compute-geotiled-4-aspect
        value: $(tasks.compute-geotiled-4.results.aspect)
      - name: compute-geotiled-5-aspect
        value: $(tasks.compute-geotiled-5.results.aspect)
      - name: compute-geotiled-6-aspect
        value: $(tasks.compute-geotiled-6.results.aspect)
      - name: compute-geotiled-7-aspect
        value: $(tasks.compute-geotiled-7.results.aspect)
      - name: compute-geotiled-8-aspect
        value: $(tasks.compute-geotiled-8.results.aspect)
      - name: compute-geotiled-9-aspect
        value: $(tasks.compute-geotiled-9.results.aspect)
      - name: compute-geotiled-aspect
        value: $(tasks.compute-geotiled.results.aspect)
      - name: container_image
        value: $(params.container_image)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      taskSpec:
        steps:
        - name: main
          args:
          - --input-files
          - '["$(inputs.params.compute-geotiled-aspect)", "$(inputs.params.compute-geotiled-2-aspect)",
            "$(inputs.params.compute-geotiled-3-aspect)", "$(inputs.params.compute-geotiled-4-aspect)",
            "$(inputs.params.compute-geotiled-5-aspect)", "$(inputs.params.compute-geotiled-6-aspect)",
            "$(inputs.params.compute-geotiled-7-aspect)", "$(inputs.params.compute-geotiled-8-aspect)",
            "$(inputs.params.compute-geotiled-9-aspect)"]'
          - --dir
          - /cos/
          - --output-file
          - /cos/aspect.tif
          - --param
          - aspect
          - '----output-paths'
          - $(results.Output.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def merge_avg(input_files, dir, output_file, param):
                import os
                import glob
                from osgeo import gdal # Install in a conda env: https://anaconda.org/conda-forge/gdal
                import subprocess
                import numpy as np

                # Import function
                def bash(argv):
                    arg_seq = [str(arg) for arg in argv]
                    proc = subprocess.Popen(arg_seq, stdout=subprocess.PIPE, stderr=subprocess.PIPE)#, shell=True)
                    proc.wait() #... unless intentionally asynchronous
                    stdout, stderr = proc.communicate()

                    # Error catching: https://stackoverflow.com/questions/5826427/can-a-python-script-execute-a-function-inside-a-bash-script
                    if proc.returncode != 0:
                        raise RuntimeError("'%s' failed, error code: '%s', stdout: '%s', stderr: '%s'" % (
                            ' '.join(arg_seq), proc.returncode, stdout.rstrip(), stderr.rstrip()))

                def reproject(input_file, output_file, projection):
                    # Projection can be EPSG:4326, .... or the path to a wkt file
                    warp_options = gdal.WarpOptions(dstSRS=projection, creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES', 'NUM_THREADS=ALL_CPUS'], multithread=True, warpOptions=['NUM_THREADS=ALL_CPUS'], dstNodata=np.nan, callback=gdal.TermProgress_nocb)
                    warp = gdal.Warp(output_file, input_file, options=warp_options)
                    warp = None  # Closes the files

                vrt = gdal.BuildVRT(dir+param+'merged.vrt', input_files)
                vrt = None  # closes file

                with open(dir+param+'merged.vrt', 'r') as f:
                    contents = f.read()

                if '<NoDataValue>' in contents:
                    nodata_value = contents[contents.index('<NoDataValue>') + len('<NoDataValue>'): contents.index('</NoDataValue>')]# To add averaging function
                else:
                    nodata_value = 0

                code = '''band="1" subClass="VRTDerivedRasterBand">
              <PixelFunctionType>average</PixelFunctionType>
              <PixelFunctionLanguage>Python</PixelFunctionLanguage>
              <PixelFunctionCode><![CDATA[
            import numpy as np

            def average(in_ar, out_ar, xoff, yoff, xsize, ysize, raster_xsize,raster_ysize, buf_radius, gt, **kwargs):
                data = np.ma.array(in_ar, mask=np.equal(in_ar, {}))
                np.mean(data, axis=0, out=out_ar, dtype="float32")
                mask = np.all(data.mask,axis = 0)
                out_ar[mask] = {}
            ]]>
              </PixelFunctionCode>'''.format(nodata_value, nodata_value)

                sub1, sub2 = contents.split('band="1">', 1)
                contents = sub1 + code + sub2

                with open(dir+param+'merged.vrt', 'w') as f:
                    f.write(contents)

                cmd = ['gdal_translate', '-co', 'COMPRESS=LZW', '-co', 'TILED=YES', '-co', 'BIGTIFF=YES', '--config', 'GDAL_VRT_ENABLE_PYTHON', 'YES', dir+param+'merged.vrt', output_file]
                bash(cmd)
                os.remove(dir+param+'merged.vrt')

                reproject(output_file, output_file, 'EPSG:4326')
                return output_file

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import json
            import argparse
            _parser = argparse.ArgumentParser(prog='Merge avg', description='')
            _parser.add_argument("--input-files", dest="input_files", type=json.loads, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--dir", dest="dir", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--output-file", dest="output_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--param", dest="param", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = merge_avg(**_parsed_args)

            _outputs = [_outputs]

            _output_serializers = [
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: compute-geotiled-2-aspect
        - name: compute-geotiled-3-aspect
        - name: compute-geotiled-4-aspect
        - name: compute-geotiled-5-aspect
        - name: compute-geotiled-6-aspect
        - name: compute-geotiled-7-aspect
        - name: compute-geotiled-8-aspect
        - name: compute-geotiled-9-aspect
        - name: compute-geotiled-aspect
        - name: container_image
        - name: pvc-geotiled-name
        results:
        - name: Output
          type: string
          description: /tmp/outputs/Output/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Merge avg", "outputs":
              [{"name": "Output", "type": "String"}], "version": "Merge avg@sha256=1f8202c0963008004a5fdc6ec319987f05f349712e598449b492209b9e9da8a3"}'
      retries: 3
    - name: merge-avg-2
      params:
      - name: compute-geotiled-2-hill
        value: $(tasks.compute-geotiled-2.results.hill)
      - name: compute-geotiled-3-hill
        value: $(tasks.compute-geotiled-3.results.hill)
      - name: compute-geotiled-4-hill
        value: $(tasks.compute-geotiled-4.results.hill)
      - name: compute-geotiled-5-hill
        value: $(tasks.compute-geotiled-5.results.hill)
      - name: compute-geotiled-6-hill
        value: $(tasks.compute-geotiled-6.results.hill)
      - name: compute-geotiled-7-hill
        value: $(tasks.compute-geotiled-7.results.hill)
      - name: compute-geotiled-8-hill
        value: $(tasks.compute-geotiled-8.results.hill)
      - name: compute-geotiled-9-hill
        value: $(tasks.compute-geotiled-9.results.hill)
      - name: compute-geotiled-hill
        value: $(tasks.compute-geotiled.results.hill)
      - name: container_image
        value: $(params.container_image)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      taskSpec:
        steps:
        - name: main
          args:
          - --input-files
          - '["$(inputs.params.compute-geotiled-hill)", "$(inputs.params.compute-geotiled-2-hill)",
            "$(inputs.params.compute-geotiled-3-hill)", "$(inputs.params.compute-geotiled-4-hill)",
            "$(inputs.params.compute-geotiled-5-hill)", "$(inputs.params.compute-geotiled-6-hill)",
            "$(inputs.params.compute-geotiled-7-hill)", "$(inputs.params.compute-geotiled-8-hill)",
            "$(inputs.params.compute-geotiled-9-hill)"]'
          - --dir
          - /cos/
          - --output-file
          - /cos/hillshading.tif
          - --param
          - hillshading
          - '----output-paths'
          - $(results.Output.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def merge_avg(input_files, dir, output_file, param):
                import os
                import glob
                from osgeo import gdal # Install in a conda env: https://anaconda.org/conda-forge/gdal
                import subprocess
                import numpy as np

                # Import function
                def bash(argv):
                    arg_seq = [str(arg) for arg in argv]
                    proc = subprocess.Popen(arg_seq, stdout=subprocess.PIPE, stderr=subprocess.PIPE)#, shell=True)
                    proc.wait() #... unless intentionally asynchronous
                    stdout, stderr = proc.communicate()

                    # Error catching: https://stackoverflow.com/questions/5826427/can-a-python-script-execute-a-function-inside-a-bash-script
                    if proc.returncode != 0:
                        raise RuntimeError("'%s' failed, error code: '%s', stdout: '%s', stderr: '%s'" % (
                            ' '.join(arg_seq), proc.returncode, stdout.rstrip(), stderr.rstrip()))

                def reproject(input_file, output_file, projection):
                    # Projection can be EPSG:4326, .... or the path to a wkt file
                    warp_options = gdal.WarpOptions(dstSRS=projection, creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES', 'NUM_THREADS=ALL_CPUS'], multithread=True, warpOptions=['NUM_THREADS=ALL_CPUS'], dstNodata=np.nan, callback=gdal.TermProgress_nocb)
                    warp = gdal.Warp(output_file, input_file, options=warp_options)
                    warp = None  # Closes the files

                vrt = gdal.BuildVRT(dir+param+'merged.vrt', input_files)
                vrt = None  # closes file

                with open(dir+param+'merged.vrt', 'r') as f:
                    contents = f.read()

                if '<NoDataValue>' in contents:
                    nodata_value = contents[contents.index('<NoDataValue>') + len('<NoDataValue>'): contents.index('</NoDataValue>')]# To add averaging function
                else:
                    nodata_value = 0

                code = '''band="1" subClass="VRTDerivedRasterBand">
              <PixelFunctionType>average</PixelFunctionType>
              <PixelFunctionLanguage>Python</PixelFunctionLanguage>
              <PixelFunctionCode><![CDATA[
            import numpy as np

            def average(in_ar, out_ar, xoff, yoff, xsize, ysize, raster_xsize,raster_ysize, buf_radius, gt, **kwargs):
                data = np.ma.array(in_ar, mask=np.equal(in_ar, {}))
                np.mean(data, axis=0, out=out_ar, dtype="float32")
                mask = np.all(data.mask,axis = 0)
                out_ar[mask] = {}
            ]]>
              </PixelFunctionCode>'''.format(nodata_value, nodata_value)

                sub1, sub2 = contents.split('band="1">', 1)
                contents = sub1 + code + sub2

                with open(dir+param+'merged.vrt', 'w') as f:
                    f.write(contents)

                cmd = ['gdal_translate', '-co', 'COMPRESS=LZW', '-co', 'TILED=YES', '-co', 'BIGTIFF=YES', '--config', 'GDAL_VRT_ENABLE_PYTHON', 'YES', dir+param+'merged.vrt', output_file]
                bash(cmd)
                os.remove(dir+param+'merged.vrt')

                reproject(output_file, output_file, 'EPSG:4326')
                return output_file

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import json
            import argparse
            _parser = argparse.ArgumentParser(prog='Merge avg', description='')
            _parser.add_argument("--input-files", dest="input_files", type=json.loads, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--dir", dest="dir", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--output-file", dest="output_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--param", dest="param", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = merge_avg(**_parsed_args)

            _outputs = [_outputs]

            _output_serializers = [
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: compute-geotiled-2-hill
        - name: compute-geotiled-3-hill
        - name: compute-geotiled-4-hill
        - name: compute-geotiled-5-hill
        - name: compute-geotiled-6-hill
        - name: compute-geotiled-7-hill
        - name: compute-geotiled-8-hill
        - name: compute-geotiled-9-hill
        - name: compute-geotiled-hill
        - name: container_image
        - name: pvc-geotiled-name
        results:
        - name: Output
          type: string
          description: /tmp/outputs/Output/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Merge avg", "outputs":
              [{"name": "Output", "type": "String"}], "version": "Merge avg@sha256=1f8202c0963008004a5fdc6ec319987f05f349712e598449b492209b9e9da8a3"}'
      retries: 3
    - name: merge-avg-3
      params:
      - name: compute-geotiled-2-slope
        value: $(tasks.compute-geotiled-2.results.slope)
      - name: compute-geotiled-3-slope
        value: $(tasks.compute-geotiled-3.results.slope)
      - name: compute-geotiled-4-slope
        value: $(tasks.compute-geotiled-4.results.slope)
      - name: compute-geotiled-5-slope
        value: $(tasks.compute-geotiled-5.results.slope)
      - name: compute-geotiled-6-slope
        value: $(tasks.compute-geotiled-6.results.slope)
      - name: compute-geotiled-7-slope
        value: $(tasks.compute-geotiled-7.results.slope)
      - name: compute-geotiled-8-slope
        value: $(tasks.compute-geotiled-8.results.slope)
      - name: compute-geotiled-9-slope
        value: $(tasks.compute-geotiled-9.results.slope)
      - name: compute-geotiled-slope
        value: $(tasks.compute-geotiled.results.slope)
      - name: container_image
        value: $(params.container_image)
      - name: pvc-geotiled-name
        value: $(tasks.pvc-geotiled.results.name)
      taskSpec:
        steps:
        - name: main
          args:
          - --input-files
          - '["$(inputs.params.compute-geotiled-slope)", "$(inputs.params.compute-geotiled-2-slope)",
            "$(inputs.params.compute-geotiled-3-slope)", "$(inputs.params.compute-geotiled-4-slope)",
            "$(inputs.params.compute-geotiled-5-slope)", "$(inputs.params.compute-geotiled-6-slope)",
            "$(inputs.params.compute-geotiled-7-slope)", "$(inputs.params.compute-geotiled-8-slope)",
            "$(inputs.params.compute-geotiled-9-slope)"]'
          - --dir
          - /cos/
          - --output-file
          - /cos/slope.tif
          - --param
          - slope
          - '----output-paths'
          - $(results.Output.path)
          command:
          - sh
          - -ec
          - |
            program_path=$(mktemp)
            printf "%s" "$0" > "$program_path"
            python3 -u "$program_path" "$@"
          - |
            def merge_avg(input_files, dir, output_file, param):
                import os
                import glob
                from osgeo import gdal # Install in a conda env: https://anaconda.org/conda-forge/gdal
                import subprocess
                import numpy as np

                # Import function
                def bash(argv):
                    arg_seq = [str(arg) for arg in argv]
                    proc = subprocess.Popen(arg_seq, stdout=subprocess.PIPE, stderr=subprocess.PIPE)#, shell=True)
                    proc.wait() #... unless intentionally asynchronous
                    stdout, stderr = proc.communicate()

                    # Error catching: https://stackoverflow.com/questions/5826427/can-a-python-script-execute-a-function-inside-a-bash-script
                    if proc.returncode != 0:
                        raise RuntimeError("'%s' failed, error code: '%s', stdout: '%s', stderr: '%s'" % (
                            ' '.join(arg_seq), proc.returncode, stdout.rstrip(), stderr.rstrip()))

                def reproject(input_file, output_file, projection):
                    # Projection can be EPSG:4326, .... or the path to a wkt file
                    warp_options = gdal.WarpOptions(dstSRS=projection, creationOptions=['COMPRESS=LZW', 'TILED=YES', 'BIGTIFF=YES', 'NUM_THREADS=ALL_CPUS'], multithread=True, warpOptions=['NUM_THREADS=ALL_CPUS'], dstNodata=np.nan, callback=gdal.TermProgress_nocb)
                    warp = gdal.Warp(output_file, input_file, options=warp_options)
                    warp = None  # Closes the files

                vrt = gdal.BuildVRT(dir+param+'merged.vrt', input_files)
                vrt = None  # closes file

                with open(dir+param+'merged.vrt', 'r') as f:
                    contents = f.read()

                if '<NoDataValue>' in contents:
                    nodata_value = contents[contents.index('<NoDataValue>') + len('<NoDataValue>'): contents.index('</NoDataValue>')]# To add averaging function
                else:
                    nodata_value = 0

                code = '''band="1" subClass="VRTDerivedRasterBand">
              <PixelFunctionType>average</PixelFunctionType>
              <PixelFunctionLanguage>Python</PixelFunctionLanguage>
              <PixelFunctionCode><![CDATA[
            import numpy as np

            def average(in_ar, out_ar, xoff, yoff, xsize, ysize, raster_xsize,raster_ysize, buf_radius, gt, **kwargs):
                data = np.ma.array(in_ar, mask=np.equal(in_ar, {}))
                np.mean(data, axis=0, out=out_ar, dtype="float32")
                mask = np.all(data.mask,axis = 0)
                out_ar[mask] = {}
            ]]>
              </PixelFunctionCode>'''.format(nodata_value, nodata_value)

                sub1, sub2 = contents.split('band="1">', 1)
                contents = sub1 + code + sub2

                with open(dir+param+'merged.vrt', 'w') as f:
                    f.write(contents)

                cmd = ['gdal_translate', '-co', 'COMPRESS=LZW', '-co', 'TILED=YES', '-co', 'BIGTIFF=YES', '--config', 'GDAL_VRT_ENABLE_PYTHON', 'YES', dir+param+'merged.vrt', output_file]
                bash(cmd)
                os.remove(dir+param+'merged.vrt')

                reproject(output_file, output_file, 'EPSG:4326')
                return output_file

            def _serialize_str(str_value: str) -> str:
                if not isinstance(str_value, str):
                    raise TypeError('Value "{}" has type "{}" instead of str.'.format(
                        str(str_value), str(type(str_value))))
                return str_value

            import json
            import argparse
            _parser = argparse.ArgumentParser(prog='Merge avg', description='')
            _parser.add_argument("--input-files", dest="input_files", type=json.loads, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--dir", dest="dir", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--output-file", dest="output_file", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("--param", dest="param", type=str, required=True, default=argparse.SUPPRESS)
            _parser.add_argument("----output-paths", dest="_output_paths", type=str, nargs=1)
            _parsed_args = vars(_parser.parse_args())
            _output_files = _parsed_args.pop("_output_paths", [])

            _outputs = merge_avg(**_parsed_args)

            _outputs = [_outputs]

            _output_serializers = [
                _serialize_str,

            ]

            import os
            for idx, output_file in enumerate(_output_files):
                try:
                    os.makedirs(os.path.dirname(output_file))
                except OSError:
                    pass
                with open(output_file, 'w') as f:
                    f.write(_output_serializers[idx](_outputs[idx]))
          image: $(inputs.params.container_image)
          volumeMounts:
          - mountPath: /cos/
            name: pvc-geotiled
        params:
        - name: compute-geotiled-2-slope
        - name: compute-geotiled-3-slope
        - name: compute-geotiled-4-slope
        - name: compute-geotiled-5-slope
        - name: compute-geotiled-6-slope
        - name: compute-geotiled-7-slope
        - name: compute-geotiled-8-slope
        - name: compute-geotiled-9-slope
        - name: compute-geotiled-slope
        - name: container_image
        - name: pvc-geotiled-name
        results:
        - name: Output
          type: string
          description: /tmp/outputs/Output/data
        volumes:
        - name: pvc-geotiled
          persistentVolumeClaim:
            claimName: $(inputs.params.pvc-geotiled-name)
        metadata:
          labels:
            pipelines.kubeflow.org/cache_enabled: "true"
          annotations:
            pipelines.kubeflow.org/component_spec_digest: '{"name": "Merge avg", "outputs":
              [{"name": "Output", "type": "String"}], "version": "Merge avg@sha256=1f8202c0963008004a5fdc6ec319987f05f349712e598449b492209b9e9da8a3"}'
      retries: 3
